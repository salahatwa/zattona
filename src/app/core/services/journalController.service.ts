// /**
//  * Halo API Documentation
//  * Documentation for Halo API
//  *
//  * OpenAPI spec version: unknown
//  * Contact: hi@halo.run
//  *
//  * NOTE: This class is auto generated by the swagger code generator program.
//  * https://github.com/swagger-api/swagger-codegen.git
//  * Do not edit the class manually.
//  */
// /* tslint:disable:no-unused-variable member-ordering */

// import { Inject, Injectable, Optional }                      from '@angular/core';
// import { HttpClient, HttpHeaders, HttpParams,
//          HttpResponse, HttpEvent }                           from '@angular/common/http';
// import { CustomHttpUrlEncodingCodec }                        from '../encoder';

// import { Observable }                                        from 'rxjs/Observable';

// import { BaseCommentDTO } from '../model/baseCommentDTO';
// import { JournalCommentParam } from '../model/journalCommentParam';
// import { JournalDTO } from '../model/journalDTO';
// import { PageBaseCommentVO } from '../model/pageBaseCommentVO';
// import { PageBaseCommentWithParentVO } from '../model/pageBaseCommentWithParentVO';
// import { PageCommentWithHasChildrenVO } from '../model/pageCommentWithHasChildrenVO';
// import { PageJournalWithCmtCountDTO } from '../model/pageJournalWithCmtCountDTO';

// import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
// import { Configuration }                                     from '../configuration';


// @Injectable()
// export class JournalControllerService {

//     protected basePath = 'https://127.0.0.1:8090';
//     public defaultHeaders = new HttpHeaders();
//     public configuration = new Configuration();

//     constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
//         if (basePath) {
//             this.basePath = basePath;
//         }
//         if (configuration) {
//             this.configuration = configuration;
//             this.basePath = basePath || configuration.basePath || this.basePath;
//         }
//     }

//     /**
//      * @param consumes string[] mime-types
//      * @return true: consumes contains 'multipart/form-data', false: otherwise
//      */
//     private canConsumeForm(consumes: string[]): boolean {
//         const form = 'multipart/form-data';
//         for (const consume of consumes) {
//             if (form === consume) {
//                 return true;
//             }
//         }
//         return false;
//     }


//     /**
//      * Comments a post
//      * 
//      * @param journalCommentParam journalCommentParam
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public commentUsingPOST(journalCommentParam: JournalCommentParam, observe?: 'body', reportProgress?: boolean): Observable<BaseCommentDTO>;
//     public commentUsingPOST(journalCommentParam: JournalCommentParam, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BaseCommentDTO>>;
//     public commentUsingPOST(journalCommentParam: JournalCommentParam, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BaseCommentDTO>>;
//     public commentUsingPOST(journalCommentParam: JournalCommentParam, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         if (journalCommentParam === null || journalCommentParam === undefined) {
//             throw new Error('Required parameter journalCommentParam was null or undefined when calling commentUsingPOST.');
//         }

//         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});

//         let headers = this.defaultHeaders;

//         // authentication (Access key from header) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["API-Authorization"]) {
//             headers = headers.set('API-Authorization', this.configuration.apiKeys["API-Authorization"]);
//         }

//         // authentication (Access key from query) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["api_access_key"]) {
//             queryParameters = queryParameters.set('api_access_key', this.configuration.apiKeys["api_access_key"]);
//         }

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             '*/*'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//             'application/json'
//         ];
//         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
//         if (httpContentTypeSelected != undefined) {
//             headers = headers.set('Content-Type', httpContentTypeSelected);
//         }

//         return this.httpClient.post<BaseCommentDTO>(`${this.basePath}/api/content/journals/comments`,
//             journalCommentParam,
//             {
//                 params: queryParameters,
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * Gets a journal detail
//      * 
//      * @param journalId journalId
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public getByUsingGET12(journalId: number, observe?: 'body', reportProgress?: boolean): Observable<JournalDTO>;
//     public getByUsingGET12(journalId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JournalDTO>>;
//     public getByUsingGET12(journalId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JournalDTO>>;
//     public getByUsingGET12(journalId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         if (journalId === null || journalId === undefined) {
//             throw new Error('Required parameter journalId was null or undefined when calling getByUsingGET12.');
//         }

//         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});

//         let headers = this.defaultHeaders;

//         // authentication (Access key from header) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["API-Authorization"]) {
//             headers = headers.set('API-Authorization', this.configuration.apiKeys["API-Authorization"]);
//         }

//         // authentication (Access key from query) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["api_access_key"]) {
//             queryParameters = queryParameters.set('api_access_key', this.configuration.apiKeys["api_access_key"]);
//         }

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             '*/*'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//         ];

//         return this.httpClient.get<JournalDTO>(`${this.basePath}/api/content/journals/${encodeURIComponent(String(journalId))}`,
//             {
//                 params: queryParameters,
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * Likes a journal
//      * 
//      * @param id id
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public likeUsingPOST(id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
//     public likeUsingPOST(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
//     public likeUsingPOST(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
//     public likeUsingPOST(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling likeUsingPOST.');
//         }

//         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});

//         let headers = this.defaultHeaders;

//         // authentication (Access key from header) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["API-Authorization"]) {
//             headers = headers.set('API-Authorization', this.configuration.apiKeys["API-Authorization"]);
//         }

//         // authentication (Access key from query) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["api_access_key"]) {
//             queryParameters = queryParameters.set('api_access_key', this.configuration.apiKeys["api_access_key"]);
//         }

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             '*/*'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//             'application/json'
//         ];

//         return this.httpClient.post<any>(`${this.basePath}/api/content/journals/${encodeURIComponent(String(id))}/likes`,
//             null,
//             {
//                 params: queryParameters,
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * listChildrenBy
//      * 
//      * @param commentParentId commentParentId
//      * @param journalId journalId
//      * @param sort 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public listChildrenByUsingGET(commentParentId: number, journalId: number, sort?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<BaseCommentDTO>>;
//     public listChildrenByUsingGET(commentParentId: number, journalId: number, sort?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BaseCommentDTO>>>;
//     public listChildrenByUsingGET(commentParentId: number, journalId: number, sort?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BaseCommentDTO>>>;
//     public listChildrenByUsingGET(commentParentId: number, journalId: number, sort?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         if (commentParentId === null || commentParentId === undefined) {
//             throw new Error('Required parameter commentParentId was null or undefined when calling listChildrenByUsingGET.');
//         }

//         if (journalId === null || journalId === undefined) {
//             throw new Error('Required parameter journalId was null or undefined when calling listChildrenByUsingGET.');
//         }


//         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
//         if (sort) {
//             sort.forEach((element) => {
//                 queryParameters = queryParameters.append('sort', <any>element);
//             })
//         }

//         let headers = this.defaultHeaders;

//         // authentication (Access key from header) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["API-Authorization"]) {
//             headers = headers.set('API-Authorization', this.configuration.apiKeys["API-Authorization"]);
//         }

//         // authentication (Access key from query) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["api_access_key"]) {
//             queryParameters = queryParameters.set('api_access_key', this.configuration.apiKeys["api_access_key"]);
//         }

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             '*/*'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//         ];

//         return this.httpClient.get<Array<BaseCommentDTO>>(`${this.basePath}/api/content/journals/${encodeURIComponent(String(journalId))}/comments/${encodeURIComponent(String(commentParentId))}/children`,
//             {
//                 params: queryParameters,
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * Lists comments with tree view
//      * 
//      * @param journalId journalId
//      * @param page page
//      * @param sort 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public listCommentsTreeUsingGET(journalId: number, page?: number, sort?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<PageBaseCommentVO>;
//     public listCommentsTreeUsingGET(journalId: number, page?: number, sort?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageBaseCommentVO>>;
//     public listCommentsTreeUsingGET(journalId: number, page?: number, sort?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageBaseCommentVO>>;
//     public listCommentsTreeUsingGET(journalId: number, page?: number, sort?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         if (journalId === null || journalId === undefined) {
//             throw new Error('Required parameter journalId was null or undefined when calling listCommentsTreeUsingGET.');
//         }



//         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
//         if (page !== undefined && page !== null) {
//             queryParameters = queryParameters.set('page', <any>page);
//         }
//         if (sort) {
//             sort.forEach((element) => {
//                 queryParameters = queryParameters.append('sort', <any>element);
//             })
//         }

//         let headers = this.defaultHeaders;

//         // authentication (Access key from header) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["API-Authorization"]) {
//             headers = headers.set('API-Authorization', this.configuration.apiKeys["API-Authorization"]);
//         }

//         // authentication (Access key from query) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["api_access_key"]) {
//             queryParameters = queryParameters.set('api_access_key', this.configuration.apiKeys["api_access_key"]);
//         }

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             '*/*'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//         ];

//         return this.httpClient.get<PageBaseCommentVO>(`${this.basePath}/api/content/journals/${encodeURIComponent(String(journalId))}/comments/tree_view`,
//             {
//                 params: queryParameters,
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * Lists comment with list view
//      * 
//      * @param journalId journalId
//      * @param page page
//      * @param sort 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public listCommentsUsingGET3(journalId: number, page?: number, sort?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<PageBaseCommentWithParentVO>;
//     public listCommentsUsingGET3(journalId: number, page?: number, sort?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageBaseCommentWithParentVO>>;
//     public listCommentsUsingGET3(journalId: number, page?: number, sort?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageBaseCommentWithParentVO>>;
//     public listCommentsUsingGET3(journalId: number, page?: number, sort?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         if (journalId === null || journalId === undefined) {
//             throw new Error('Required parameter journalId was null or undefined when calling listCommentsUsingGET3.');
//         }



//         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
//         if (page !== undefined && page !== null) {
//             queryParameters = queryParameters.set('page', <any>page);
//         }
//         if (sort) {
//             sort.forEach((element) => {
//                 queryParameters = queryParameters.append('sort', <any>element);
//             })
//         }

//         let headers = this.defaultHeaders;

//         // authentication (Access key from header) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["API-Authorization"]) {
//             headers = headers.set('API-Authorization', this.configuration.apiKeys["API-Authorization"]);
//         }

//         // authentication (Access key from query) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["api_access_key"]) {
//             queryParameters = queryParameters.set('api_access_key', this.configuration.apiKeys["api_access_key"]);
//         }

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             '*/*'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//         ];

//         return this.httpClient.get<PageBaseCommentWithParentVO>(`${this.basePath}/api/content/journals/${encodeURIComponent(String(journalId))}/comments/list_view`,
//             {
//                 params: queryParameters,
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * listTopComments
//      * 
//      * @param journalId journalId
//      * @param page page
//      * @param sort 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public listTopCommentsUsingGET(journalId: number, page?: number, sort?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<PageCommentWithHasChildrenVO>;
//     public listTopCommentsUsingGET(journalId: number, page?: number, sort?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageCommentWithHasChildrenVO>>;
//     public listTopCommentsUsingGET(journalId: number, page?: number, sort?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageCommentWithHasChildrenVO>>;
//     public listTopCommentsUsingGET(journalId: number, page?: number, sort?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         if (journalId === null || journalId === undefined) {
//             throw new Error('Required parameter journalId was null or undefined when calling listTopCommentsUsingGET.');
//         }



//         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
//         if (page !== undefined && page !== null) {
//             queryParameters = queryParameters.set('page', <any>page);
//         }
//         if (sort) {
//             sort.forEach((element) => {
//                 queryParameters = queryParameters.append('sort', <any>element);
//             })
//         }

//         let headers = this.defaultHeaders;

//         // authentication (Access key from header) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["API-Authorization"]) {
//             headers = headers.set('API-Authorization', this.configuration.apiKeys["API-Authorization"]);
//         }

//         // authentication (Access key from query) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["api_access_key"]) {
//             queryParameters = queryParameters.set('api_access_key', this.configuration.apiKeys["api_access_key"]);
//         }

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             '*/*'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//         ];

//         return this.httpClient.get<PageCommentWithHasChildrenVO>(`${this.basePath}/api/content/journals/${encodeURIComponent(String(journalId))}/comments/top_view`,
//             {
//                 params: queryParameters,
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * Lists journals
//      * 
//      * @param page 
//      * @param size 
//      * @param sort 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public pageByUsingGET9(page?: number, size?: number, sort?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<PageJournalWithCmtCountDTO>;
//     public pageByUsingGET9(page?: number, size?: number, sort?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageJournalWithCmtCountDTO>>;
//     public pageByUsingGET9(page?: number, size?: number, sort?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageJournalWithCmtCountDTO>>;
//     public pageByUsingGET9(page?: number, size?: number, sort?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




//         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
//         if (page !== undefined && page !== null) {
//             queryParameters = queryParameters.set('page', <any>page);
//         }
//         if (size !== undefined && size !== null) {
//             queryParameters = queryParameters.set('size', <any>size);
//         }
//         if (sort) {
//             sort.forEach((element) => {
//                 queryParameters = queryParameters.append('sort', <any>element);
//             })
//         }

//         let headers = this.defaultHeaders;

//         // authentication (Access key from header) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["API-Authorization"]) {
//             headers = headers.set('API-Authorization', this.configuration.apiKeys["API-Authorization"]);
//         }

//         // authentication (Access key from query) required
//         if (this.configuration.apiKeys && this.configuration.apiKeys["api_access_key"]) {
//             queryParameters = queryParameters.set('api_access_key', this.configuration.apiKeys["api_access_key"]);
//         }

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             '*/*'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//         ];

//         return this.httpClient.get<PageJournalWithCmtCountDTO>(`${this.basePath}/api/content/journals`,
//             {
//                 params: queryParameters,
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

// }
