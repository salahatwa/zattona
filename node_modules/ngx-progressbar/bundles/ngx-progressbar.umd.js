(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators'), require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-progressbar', ['exports', 'rxjs', 'rxjs/operators', '@angular/core', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-progressbar'] = {}, global.rxjs, global.rxjs.operators, global.ng.core, global.ng.common));
}(this, (function (exports, rxjs, operators, i0, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var NgProgressRef = /** @class */ (function () {
        function NgProgressRef(customConfig, _onDestroyCallback) {
            var _this = this;
            this._onDestroyCallback = _onDestroyCallback;
            // Progress start source event (used to cancel finalizing delays)
            this._started = new rxjs.Subject();
            // Progress start event: stream that emits only when it hasn't already started
            this.started = this._started.pipe(operators.filter(function () { return !_this.isStarted; }));
            // Progress ended source event
            this._completed = new rxjs.Subject();
            // Progress start event: stream that emits only when it has already started
            this.completed = this._completed.pipe(operators.filter(function () { return _this.isStarted; }));
            // Stream that increments and updates the progress state
            this._trickling = new rxjs.Subject();
            // Stream that combines "_trickling" and "config" streams
            this._worker = rxjs.Subscription.EMPTY;
            this._state = new rxjs.BehaviorSubject({ active: false, value: 0 });
            this._config = new rxjs.BehaviorSubject(customConfig);
            this.state = this._state.asObservable();
            this.config = this._config.asObservable();
            this._worker = rxjs.combineLatest([this._trickling, this._config]).pipe(operators.debounce(function (_a) {
                var _b = __read(_a, 2), start = _b[0], config = _b[1];
                return rxjs.timer(start ? config.debounceTime : 0);
            }), operators.switchMap(function (_a) {
                var _b = __read(_a, 2), start = _b[0], config = _b[1];
                return start ? _this.onTrickling(config) : _this.onComplete(config);
            })).subscribe();
        }
        Object.defineProperty(NgProgressRef.prototype, "snapshot", {
            // Get current progress state
            get: function () {
                return this._state.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgProgressRef.prototype, "isStarted", {
            // Check if progress has started
            get: function () {
                return this.snapshot.active;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Start the progress
         */
        NgProgressRef.prototype.start = function () {
            this._started.next();
            this._trickling.next(true);
        };
        /**
         * Complete the progress
         */
        NgProgressRef.prototype.complete = function () {
            this._trickling.next(false);
        };
        /**
         * Increment the progress
         */
        NgProgressRef.prototype.inc = function (amount) {
            var n = this.snapshot.value;
            if (!this.isStarted) {
                this.start();
            }
            else {
                if (typeof amount !== 'number') {
                    amount = this._config.value.trickleFunc(n);
                }
                this.set(n + amount);
            }
        };
        /**
         * Set the progress
         */
        NgProgressRef.prototype.set = function (n) {
            this.setState({ value: this.clamp(n), active: true });
        };
        /**
         * Set config
         */
        NgProgressRef.prototype.setConfig = function (config) {
            this._config.next(Object.assign(Object.assign({}, this._config.value), config));
        };
        /**
         * Destroy progress reference
         */
        NgProgressRef.prototype.destroy = function () {
            this._worker.unsubscribe();
            this._trickling.complete();
            this._state.complete();
            this._config.complete();
            this._started.complete();
            this._completed.complete();
            this._onDestroyCallback();
        };
        /**
         * Set progress state
         */
        NgProgressRef.prototype.setState = function (state) {
            this._state.next(Object.assign(Object.assign({}, this.snapshot), state));
        };
        /**
         * Clamps a value to be between min and max
         */
        NgProgressRef.prototype.clamp = function (n) {
            return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
        };
        /**
         * Keeps incrementing the progress
         */
        NgProgressRef.prototype.onTrickling = function (config) {
            var _this = this;
            if (!this.isStarted) {
                this.set(this._config.value.min);
            }
            return rxjs.timer(0, config.trickleSpeed).pipe(operators.tap(function () { return _this.inc(); }));
        };
        /**
         * Completes then resets the progress
         */
        NgProgressRef.prototype.onComplete = function (config) {
            var _this = this;
            this._completed.next();
            return !this.isStarted ? rxjs.EMPTY : rxjs.of({}).pipe(
            // Complete the progress
            operators.tap(function () { return _this.setState({ value: 100 }); }), 
            // Deactivate the progress after a tiny delay
            operators.delay(config.speed * 1.7), operators.tap(function () { return _this.setState({ active: false }); }), 
            // Use a tiny delay before resetting
            operators.delay(config.speed), 
            // Force the progress to reset even it got cancelled
            operators.finalize(function () { return _this.setState({ value: 0 }); }), 
            // Cancel any of the finalizing delays if the progress has started again
            operators.takeUntil(this._started));
        };
        return NgProgressRef;
    }());

    var NG_PROGRESS_CONFIG = new i0.InjectionToken('ngProgressConfig');

    var ɵ0 = function (n) {
        if (n >= 0 && n < 20)
            return 10;
        if (n >= 20 && n < 50)
            return 4;
        if (n >= 50 && n < 80)
            return 2;
        if (n >= 80 && n < 99)
            return 0.5;
        return 0;
    };
    var defaultConfig = {
        min: 8,
        max: 100,
        speed: 200,
        debounceTime: 0,
        trickleSpeed: 300,
        fixed: true,
        meteor: true,
        thick: false,
        spinner: true,
        ease: 'linear',
        color: '#1B95E0',
        direction: 'ltr+',
        spinnerPosition: 'right',
        trickleFunc: ɵ0
    };
    var NgProgress = /** @class */ (function () {
        function NgProgress(config) {
            // Store progress bar instances
            this._instances = new Map();
            this.config = config ? Object.assign(Object.assign({}, defaultConfig), config) : defaultConfig;
        }
        /**
         * Get or Create progress bar by ID
         */
        NgProgress.prototype.ref = function (id, config) {
            if (id === void 0) { id = 'root'; }
            if (this._instances.has(id)) {
                // Get ProgressRef instance
                var progressRef = this._instances.get(id);
                if (config) {
                    progressRef.setConfig(Object.assign(Object.assign({}, this.config), config));
                }
                return progressRef;
            }
            else {
                // Create new ProgressRef instance
                var progressRef = new NgProgressRef(Object.assign(Object.assign({}, this.config), config), this.deleteInstance(id));
                return this._instances.set(id, progressRef).get(id);
            }
        };
        /**
         * Destroy all progress bar instances
         */
        NgProgress.prototype.destroyAll = function () {
            this._instances.forEach(function (ref) { return ref.destroy(); });
        };
        /**
         * A destroyer function for each progress bar instance
         */
        NgProgress.prototype.deleteInstance = function (id) {
            var _this = this;
            return function () {
                _this._instances.delete(id);
            };
        };
        return NgProgress;
    }());
    NgProgress.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgProgress_Factory() { return new NgProgress(i0.ɵɵinject(NG_PROGRESS_CONFIG, 8)); }, token: NgProgress, providedIn: "root" });
    NgProgress.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    NgProgress.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [NG_PROGRESS_CONFIG,] }] }
    ]; };

    var NgProgressComponent = /** @class */ (function () {
        function NgProgressComponent(_ngProgress) {
            this._ngProgress = _ngProgress;
            /** Creates a new instance if id is not already exists */
            this.id = 'root';
            /** Initializes inputs from the global config */
            this.min = this._ngProgress.config.min;
            this.max = this._ngProgress.config.max;
            this.ease = this._ngProgress.config.ease;
            this.color = this._ngProgress.config.color;
            this.speed = this._ngProgress.config.speed;
            this.thick = this._ngProgress.config.thick;
            this.fixed = this._ngProgress.config.fixed;
            this.meteor = this._ngProgress.config.meteor;
            this.spinner = this._ngProgress.config.spinner;
            this.trickleSpeed = this._ngProgress.config.trickleSpeed;
            this.debounceTime = this._ngProgress.config.debounceTime;
            this.trickleFunc = this._ngProgress.config.trickleFunc;
            this.spinnerPosition = this._ngProgress.config.spinnerPosition;
            this.direction = this._ngProgress.config.direction;
            this.started = new i0.EventEmitter();
            this.completed = new i0.EventEmitter();
        }
        Object.defineProperty(NgProgressComponent.prototype, "isStarted", {
            get: function () {
                var _a;
                return (_a = this.progressRef) === null || _a === void 0 ? void 0 : _a.isStarted;
            },
            enumerable: false,
            configurable: true
        });
        NgProgressComponent.prototype.ngOnChanges = function () {
            var _a;
            // Update progress bar config when inputs change
            (_a = this.progressRef) === null || _a === void 0 ? void 0 : _a.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        };
        NgProgressComponent.prototype.ngOnInit = function () {
            var _this = this;
            // Get progress bar service instance
            this.progressRef = this._ngProgress.ref(this.id, {
                max: this.max,
                min: this.min,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                debounceTime: this.debounceTime
            });
            // Subscribe to progress state
            this.state$ = this.progressRef.state.pipe(operators.map(function (state) { return ({
                active: state.active,
                transform: "translate3d(" + state.value + "%,0,0)"
            }); }));
            // Subscribes to started and completed events on demand
            if (this.started.observers.length) {
                this._started = this.progressRef.started.subscribe(function () { return _this.started.emit(); });
            }
            if (this.completed.observers.length) {
                this._completed = this.progressRef.completed.subscribe(function () { return _this.completed.emit(); });
            }
        };
        NgProgressComponent.prototype.ngOnDestroy = function () {
            var _a, _b, _c;
            (_a = this._started) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            (_b = this._completed) === null || _b === void 0 ? void 0 : _b.unsubscribe();
            (_c = this.progressRef) === null || _c === void 0 ? void 0 : _c.destroy();
        };
        NgProgressComponent.prototype.start = function () {
            this.progressRef.start();
        };
        NgProgressComponent.prototype.complete = function () {
            this.progressRef.complete();
        };
        NgProgressComponent.prototype.inc = function (n) {
            this.progressRef.inc(n);
        };
        NgProgressComponent.prototype.set = function (n) {
            this.progressRef.set(n);
        };
        return NgProgressComponent;
    }());
    NgProgressComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ng-progress',
                    host: {
                        'role': 'progressbar',
                        '[attr.spinnerPosition]': 'spinnerPosition',
                        '[attr.dir]': 'direction',
                        '[attr.thick]': 'thick',
                        '[attr.fixed]': 'fixed'
                    },
                    template: "\n    <ng-container *ngIf=\"state$ | async; let state\">\n      <div class=\"ng-progress-bar\"\n           [attr.active]=\"state.active\"\n           [style.transition]=\"'opacity ' + speed + 'ms ' + ease\">\n        <div class=\"ng-bar-placeholder\">\n          <div class=\"ng-bar\"\n               [style.transform]=\"state.transform\"\n               [style.backgroundColor]=\"color\"\n               [style.transition]=\"state.active ? 'all ' + speed + 'ms ' + ease : 'none'\">\n            <div *ngIf=\"meteor\" class=\"ng-meteor\" [style.boxShadow]=\"'0 0 10px '+ color + ', 0 0 5px ' + color\"></div>\n          </div>\n        </div>\n        <div *ngIf=\"spinner\" class=\"ng-spinner\">\n          <div class=\"ng-spinner-icon\"\n               [style.borderTopColor]=\"color\"\n               [style.borderLeftColor]=\"color\"></div>\n        </div>\n      </div>\n    </ng-container>\n  ",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    styles: [":host{pointer-events:none;z-index:999999}:host[fixed=true] .ng-progress-bar,:host[fixed=true] .ng-spinner{position:fixed}:host[fixed=true] .ng-spinner{top:15px}:host[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}:host[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}:host[thick=true] .ng-spinner-icon{border-width:3px;height:24px;width:24px}:host[thick=true] .ng-bar-placeholder{height:3px!important}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{transform:rotate(3deg)}:host[dir=\"ltr+\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{transform:rotate(4deg)}:host[dir=\"ltr+\"] .ng-bar,:host[dir=\"rtl+\"] .ng-bar{margin-left:-100%}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=\"rtl+\"] .ng-meteor{right:0}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{top:-3px}:host[dir=\"ltr+\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{top:-4px}:host[dir=\"rtl+\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{bottom:-3px}:host[dir=\"rtl+\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}:host[dir=\"rtl+\"] .ng-bar-placeholder,:host[dir=ltr-] .ng-bar-placeholder{transform:rotate(180deg)}:host[dir=\"rtl+\"] .ng-spinner-icon,:host[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}:host[dir=\"rtl+\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{transform:rotate(-3deg)}:host[dir=\"rtl+\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{transform:rotate(-4deg)}:host[spinnerPosition=left] .ng-spinner{left:10px}:host[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{filter:alpha(opacity=0);left:0;opacity:0;position:relative;top:0;width:100%;z-index:999999;zoom:1}.ng-progress-bar[active=true]{filter:alpha(opacity=100);opacity:1;transition:none}.ng-bar-placeholder{height:2px;position:absolute;width:100%}.ng-bar{height:100%;transform:translate(-100%);width:100%}.ng-meteor{height:100%;opacity:1;width:100px}.ng-meteor,.ng-spinner{display:block;position:absolute}.ng-spinner{top:10px;z-index:1031}.ng-spinner-icon{-webkit-animation:spinner-animation .25s linear infinite;animation:spinner-animation .25s linear infinite;border:2px solid transparent;border-radius:50%;box-sizing:border-box;height:18px;width:18px}@-webkit-keyframes spinner-animation{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@keyframes spinner-animation{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}"]
                },] }
    ];
    NgProgressComponent.ctorParameters = function () { return [
        { type: NgProgress }
    ]; };
    NgProgressComponent.propDecorators = {
        id: [{ type: i0.Input }],
        min: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        ease: [{ type: i0.Input }],
        color: [{ type: i0.Input }],
        speed: [{ type: i0.Input }],
        thick: [{ type: i0.Input }],
        fixed: [{ type: i0.Input }],
        meteor: [{ type: i0.Input }],
        spinner: [{ type: i0.Input }],
        trickleSpeed: [{ type: i0.Input }],
        debounceTime: [{ type: i0.Input }],
        trickleFunc: [{ type: i0.Input }],
        spinnerPosition: [{ type: i0.Input }],
        direction: [{ type: i0.Input }],
        started: [{ type: i0.Output }],
        completed: [{ type: i0.Output }]
    };

    var NgProgressModule = /** @class */ (function () {
        function NgProgressModule() {
        }
        NgProgressModule.withConfig = function (config) {
            return {
                ngModule: NgProgressModule,
                providers: [
                    { provide: NG_PROGRESS_CONFIG, useValue: config }
                ]
            };
        };
        return NgProgressModule;
    }());
    NgProgressModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [NgProgressComponent],
                    exports: [NgProgressComponent],
                    imports: [common.CommonModule]
                },] }
    ];

    /*
     * Public API Surface of ngx-progressbar
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NG_PROGRESS_CONFIG = NG_PROGRESS_CONFIG;
    exports.NgProgress = NgProgress;
    exports.NgProgressComponent = NgProgressComponent;
    exports.NgProgressModule = NgProgressModule;
    exports.NgProgressRef = NgProgressRef;
    exports.ɵ0 = ɵ0;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-progressbar.umd.js.map
