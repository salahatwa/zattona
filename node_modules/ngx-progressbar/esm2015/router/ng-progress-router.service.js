import { Injectable, Optional, Inject } from '@angular/core';
import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';
import { of } from 'rxjs';
import { tap, delay, switchMap, filter } from 'rxjs/operators';
import { NgProgress } from 'ngx-progressbar';
import { NG_PROGRESS_ROUTER_CONFIG } from './ng-progress-router.interface';
import * as i0 from "@angular/core";
import * as i1 from "ngx-progressbar";
import * as i2 from "@angular/router";
import * as i3 from "./ng-progress-router.interface";
/**
 * Check if a router event type exists in an array of router event types
 */
function eventExists(routerEvent, events) {
    let res = false;
    events.map((event) => res = res || routerEvent instanceof event);
    return res;
}
export class NgProgressRouter {
    constructor(progress, router, config) {
        this._config = {
            id: 'root',
            delay: 0,
            startEvents: [NavigationStart],
            completeEvents: [NavigationEnd, NavigationCancel, NavigationError]
        };
        this._config = config ? Object.assign(Object.assign({}, this._config), config) : this._config;
        const progressRef = progress.ref(this._config.id);
        const startProgress = of({}).pipe(tap(() => progressRef.start()));
        const completeProgress = of({}).pipe(delay(this._config.delay), tap(() => progressRef.complete()));
        const filterEvents = [...this._config.startEvents, ...this._config.completeEvents];
        router.events.pipe(filter((event) => eventExists(event, filterEvents)), switchMap((event) => eventExists(event, this._config.startEvents) ? startProgress : completeProgress)).subscribe();
    }
}
NgProgressRouter.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgProgressRouter_Factory() { return new NgProgressRouter(i0.ɵɵinject(i1.NgProgress), i0.ɵɵinject(i2.Router), i0.ɵɵinject(i3.NG_PROGRESS_ROUTER_CONFIG, 8)); }, token: NgProgressRouter, providedIn: "root" });
NgProgressRouter.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NgProgressRouter.ctorParameters = () => [
    { type: NgProgress },
    { type: Router },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_PROGRESS_ROUTER_CONFIG,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3Mtcm91dGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXByb2dyZXNzYmFyL3JvdXRlci9zcmMvIiwic291cmNlcyI6WyJuZy1wcm9ncmVzcy1yb3V0ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBc0IsTUFBTSxpQkFBaUIsQ0FBQztBQUNoSSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzFCLE9BQU8sRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsVUFBVSxFQUFpQixNQUFNLGlCQUFpQixDQUFDO0FBQzVELE9BQU8sRUFBZ0QseUJBQXlCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7Ozs7QUFFekg7O0dBRUc7QUFDSCxTQUFTLFdBQVcsQ0FBQyxXQUFrQixFQUFFLE1BQTJCO0lBQ2xFLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQztJQUNoQixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBd0IsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxXQUFXLFlBQVksS0FBSyxDQUFDLENBQUM7SUFDcEYsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBS0QsTUFBTSxPQUFPLGdCQUFnQjtJQVEzQixZQUFZLFFBQW9CLEVBQUUsTUFBYyxFQUFpRCxNQUE4QjtRQVA5RyxZQUFPLEdBQXlCO1lBQy9DLEVBQUUsRUFBRSxNQUFNO1lBQ1YsS0FBSyxFQUFFLENBQUM7WUFDUixXQUFXLEVBQUUsQ0FBQyxlQUFlLENBQUM7WUFDOUIsY0FBYyxFQUFFLENBQUMsYUFBYSxFQUFFLGdCQUFnQixFQUFFLGVBQWUsQ0FBQztTQUNuRSxDQUFDO1FBR0EsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsQ0FBQyxpQ0FBSyxJQUFJLENBQUMsT0FBTyxHQUFLLE1BQU0sRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUNwRSxNQUFNLFdBQVcsR0FBa0IsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWpFLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQy9CLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FDL0IsQ0FBQztRQUVGLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDbEMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQ3pCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDbEMsQ0FBQztRQUVGLE1BQU0sWUFBWSxHQUF3QixDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXhHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUNoQixNQUFNLENBQUMsQ0FBQyxLQUFZLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUMsRUFDMUQsU0FBUyxDQUFDLENBQUMsS0FBWSxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FDN0csQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUNoQixDQUFDOzs7O1lBOUJGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBZFEsVUFBVTtZQUhWLE1BQU07NENBMEJzQyxRQUFRLFlBQUksTUFBTSxTQUFDLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBJbmplY3QsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciwgTmF2aWdhdGlvblN0YXJ0LCBOYXZpZ2F0aW9uRW5kLCBOYXZpZ2F0aW9uQ2FuY2VsLCBOYXZpZ2F0aW9uRXJyb3IsIFJvdXRlckV2ZW50LCBFdmVudCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFwLCBkZWxheSwgc3dpdGNoTWFwLCBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOZ1Byb2dyZXNzLCBOZ1Byb2dyZXNzUmVmIH0gZnJvbSAnbmd4LXByb2dyZXNzYmFyJztcbmltcG9ydCB7IE5nUHJvZ3Jlc3NSb3V0ZXJDb25maWcsIFByb2dyZXNzUm91dGVyQ29uZmlnLCBOR19QUk9HUkVTU19ST1VURVJfQ09ORklHIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy1yb3V0ZXIuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHJvdXRlciBldmVudCB0eXBlIGV4aXN0cyBpbiBhbiBhcnJheSBvZiByb3V0ZXIgZXZlbnQgdHlwZXNcbiAqL1xuZnVuY3Rpb24gZXZlbnRFeGlzdHMocm91dGVyRXZlbnQ6IEV2ZW50LCBldmVudHM6IFR5cGU8Um91dGVyRXZlbnQ+W10pOiBib29sZWFuIHtcbiAgbGV0IHJlcyA9IGZhbHNlO1xuICBldmVudHMubWFwKChldmVudDogVHlwZTxSb3V0ZXJFdmVudD4pID0+IHJlcyA9IHJlcyB8fCByb3V0ZXJFdmVudCBpbnN0YW5jZW9mIGV2ZW50KTtcbiAgcmV0dXJuIHJlcztcbn1cblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc1JvdXRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbmZpZzogUHJvZ3Jlc3NSb3V0ZXJDb25maWcgPSB7XG4gICAgaWQ6ICdyb290JyxcbiAgICBkZWxheTogMCxcbiAgICBzdGFydEV2ZW50czogW05hdmlnYXRpb25TdGFydF0sXG4gICAgY29tcGxldGVFdmVudHM6IFtOYXZpZ2F0aW9uRW5kLCBOYXZpZ2F0aW9uQ2FuY2VsLCBOYXZpZ2F0aW9uRXJyb3JdXG4gIH07XG5cbiAgY29uc3RydWN0b3IocHJvZ3Jlc3M6IE5nUHJvZ3Jlc3MsIHJvdXRlcjogUm91dGVyLCBAT3B0aW9uYWwoKSBASW5qZWN0KE5HX1BST0dSRVNTX1JPVVRFUl9DT05GSUcpIGNvbmZpZzogTmdQcm9ncmVzc1JvdXRlckNvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyA/IHsuLi50aGlzLl9jb25maWcsIC4uLmNvbmZpZ30gOiB0aGlzLl9jb25maWc7XG4gICAgY29uc3QgcHJvZ3Jlc3NSZWY6IE5nUHJvZ3Jlc3NSZWYgPSBwcm9ncmVzcy5yZWYodGhpcy5fY29uZmlnLmlkKTtcblxuICAgIGNvbnN0IHN0YXJ0UHJvZ3Jlc3MgPSBvZih7fSkucGlwZShcbiAgICAgIHRhcCgoKSA9PiBwcm9ncmVzc1JlZi5zdGFydCgpKVxuICAgICk7XG5cbiAgICBjb25zdCBjb21wbGV0ZVByb2dyZXNzID0gb2Yoe30pLnBpcGUoXG4gICAgICBkZWxheSh0aGlzLl9jb25maWcuZGVsYXkpLFxuICAgICAgdGFwKCgpID0+IHByb2dyZXNzUmVmLmNvbXBsZXRlKCkpXG4gICAgKTtcblxuICAgIGNvbnN0IGZpbHRlckV2ZW50czogVHlwZTxSb3V0ZXJFdmVudD5bXSA9IFsuLi50aGlzLl9jb25maWcuc3RhcnRFdmVudHMsIC4uLnRoaXMuX2NvbmZpZy5jb21wbGV0ZUV2ZW50c107XG5cbiAgICByb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgICBmaWx0ZXIoKGV2ZW50OiBFdmVudCkgPT4gZXZlbnRFeGlzdHMoZXZlbnQsIGZpbHRlckV2ZW50cykpLFxuICAgICAgc3dpdGNoTWFwKChldmVudDogRXZlbnQpID0+IGV2ZW50RXhpc3RzKGV2ZW50LCB0aGlzLl9jb25maWcuc3RhcnRFdmVudHMpID8gc3RhcnRQcm9ncmVzcyA6IGNvbXBsZXRlUHJvZ3Jlc3MpXG4gICAgKS5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19