Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@angular/core");
var router_1 = require("@angular/router");
var browser_1 = require("@sentry/browser");
var utils_1 = require("@sentry/utils");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var zone_1 = require("./zone");
var instrumentationInitialized;
var stashedStartTransaction;
var stashedStartTransactionOnLocationChange;
/**
 * Creates routing instrumentation for Angular Router.
 */
function routingInstrumentation(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
    if (startTransactionOnPageLoad === void 0) { startTransactionOnPageLoad = true; }
    if (startTransactionOnLocationChange === void 0) { startTransactionOnLocationChange = true; }
    instrumentationInitialized = true;
    stashedStartTransaction = customStartTransaction;
    stashedStartTransactionOnLocationChange = startTransactionOnLocationChange;
    if (startTransactionOnPageLoad) {
        customStartTransaction({
            name: window.location.pathname,
            op: 'pageload',
        });
    }
}
exports.routingInstrumentation = routingInstrumentation;
exports.instrumentAngularRouting = routingInstrumentation;
/**
 * Grabs active transaction off scope
 */
function getActiveTransaction() {
    var currentHub = browser_1.getCurrentHub();
    if (currentHub) {
        var scope = currentHub.getScope();
        if (scope) {
            return scope.getTransaction();
        }
    }
    return undefined;
}
exports.getActiveTransaction = getActiveTransaction;
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
var TraceService = /** @class */ (function () {
    function TraceService(_router) {
        var _this = this;
        this._router = _router;
        this.navStart$ = this._router.events.pipe(operators_1.filter(function (event) { return event instanceof router_1.NavigationStart; }), operators_1.tap(function (event) {
            if (!instrumentationInitialized) {
                utils_1.logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            var navigationEvent = event;
            var strippedUrl = utils_1.stripUrlQueryAndFragment(navigationEvent.url);
            var activeTransaction = getActiveTransaction();
            if (!activeTransaction && stashedStartTransactionOnLocationChange) {
                activeTransaction = stashedStartTransaction({
                    name: strippedUrl,
                    op: 'navigation',
                });
            }
            if (activeTransaction) {
                _this._routingSpan = activeTransaction.startChild({
                    description: "" + navigationEvent.url,
                    op: "angular.routing",
                    tags: tslib_1.__assign({ 'routing.instrumentation': '@sentry/angular', url: strippedUrl }, (navigationEvent.navigationTrigger && {
                        navigationTrigger: navigationEvent.navigationTrigger,
                    })),
                });
            }
        }));
        this.navEnd$ = this._router.events.pipe(operators_1.filter(function (event) { return event instanceof router_1.NavigationEnd; }), operators_1.tap(function () {
            if (_this._routingSpan) {
                zone_1.runOutsideAngular(function () {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    _this._routingSpan.finish();
                });
                _this._routingSpan = null;
            }
        }));
        this._routingSpan = null;
        this._subscription = new rxjs_1.Subscription();
        this._subscription.add(this.navStart$.subscribe());
        this._subscription.add(this.navEnd$.subscribe());
    }
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    TraceService.prototype.ngOnDestroy = function () {
        this._subscription.unsubscribe();
    };
    TraceService = tslib_1.__decorate([
        core_1.Injectable({ providedIn: 'root' })
    ], TraceService);
    return TraceService;
}());
exports.TraceService = TraceService;
var UNKNOWN_COMPONENT = 'unknown';
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
var TraceDirective = /** @class */ (function () {
    function TraceDirective() {
        this.componentName = UNKNOWN_COMPONENT;
    }
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    TraceDirective.prototype.ngOnInit = function () {
        var activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            this._tracingSpan = activeTransaction.startChild({
                description: "<" + this.componentName + ">",
                op: "angular.initialize",
            });
        }
    };
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    TraceDirective.prototype.ngAfterViewInit = function () {
        if (this._tracingSpan) {
            this._tracingSpan.finish();
        }
    };
    tslib_1.__decorate([
        core_1.Input('trace')
    ], TraceDirective.prototype, "componentName", void 0);
    TraceDirective = tslib_1.__decorate([
        core_1.Directive({ selector: '[trace]' })
    ], TraceDirective);
    return TraceDirective;
}());
exports.TraceDirective = TraceDirective;
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
var TraceModule = /** @class */ (function () {
    function TraceModule() {
    }
    TraceModule = tslib_1.__decorate([
        core_1.NgModule({
            declarations: [TraceDirective],
            exports: [TraceDirective],
        })
    ], TraceModule);
    return TraceModule;
}());
exports.TraceModule = TraceModule;
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
function TraceClassDecorator() {
    var tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    return function (target) {
        var originalOnInit = target.prototype.ngOnInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngOnInit = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                tracingSpan = activeTransaction.startChild({
                    description: "<" + target.name + ">",
                    op: "angular.initialize",
                });
            }
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        var originalAfterViewInit = target.prototype.ngAfterViewInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngAfterViewInit = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (tracingSpan) {
                tracingSpan.finish();
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
exports.TraceClassDecorator = TraceClassDecorator;
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
function TraceMethodDecorator() {
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/ban-types
    return function (target, propertyKey, descriptor) {
        var originalMethod = descriptor.value;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var now = utils_1.timestampWithMs();
            var activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                activeTransaction.startChild({
                    description: "<" + target.constructor.name + ">",
                    endTimestamp: now,
                    op: "angular." + String(propertyKey),
                    startTimestamp: now,
                });
            }
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
exports.TraceMethodDecorator = TraceMethodDecorator;
//# sourceMappingURL=tracing.js.map