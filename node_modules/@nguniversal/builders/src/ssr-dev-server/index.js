/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/builders/src/ssr-dev-server/index", ["require", "exports", "@angular-devkit/architect", "@angular-devkit/core", "browser-sync", "http-proxy-middleware", "path", "rxjs", "rxjs/operators", "url", "@nguniversal/builders/src/ssr-dev-server/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.execute = void 0;
    const architect_1 = require("@angular-devkit/architect");
    const core_1 = require("@angular-devkit/core");
    const browserSync = require("browser-sync");
    const http_proxy_middleware_1 = require("http-proxy-middleware");
    const path_1 = require("path");
    const rxjs_1 = require("rxjs");
    const operators_1 = require("rxjs/operators");
    const url = require("url");
    const utils_1 = require("@nguniversal/builders/src/ssr-dev-server/utils");
    /** Log messages to ignore and not rely to the logger */
    const IGNORED_STDOUT_MESSAGES = [
        'server listening on',
        'Angular is running in development mode. Call enableProdMode() to enable production mode.'
    ];
    function execute(options, context) {
        const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
        const serverTarget = architect_1.targetFromTargetString(options.serverTarget);
        const getBaseUrl = (bs) => `${bs.getOption('scheme')}://${bs.getOption('host')}:${bs.getOption('port')}`;
        const browserTargetRun = context.scheduleTarget(browserTarget, {
            serviceWorker: false,
            watch: true,
            progress: options.progress,
        });
        const serverTargetRun = context.scheduleTarget(serverTarget, {
            watch: true,
            progress: options.progress,
        });
        const bsInstance = browserSync.create();
        context.logger.error(core_1.tags.stripIndents `
  ****************************************************************************************
  This is a simple server for use in testing or debugging Angular applications locally.
  It hasn't been reviewed for security issues.

  DON'T USE IT FOR PRODUCTION!
  ****************************************************************************************
 `);
        return rxjs_1.zip(browserTargetRun, serverTargetRun, utils_1.getAvailablePort()).pipe(operators_1.switchMap(([br, sr, nodeServerPort]) => {
            return rxjs_1.combineLatest([br.output, sr.output]).pipe(
            // This is needed so that if both server and browser emit close to each other
            // we only emit once. This typically happens on the first build.
            operators_1.debounceTime(120), operators_1.switchMap(([b, s]) => {
                if (!s.success || !b.success) {
                    return rxjs_1.of([b, s]);
                }
                return startNodeServer(s, nodeServerPort, context.logger, !!options.inspect).pipe(operators_1.mapTo([b, s]), operators_1.catchError(err => {
                    context.logger.error(`A server error has occurred.\n${mapErrorToMessage(err)}`);
                    return rxjs_1.EMPTY;
                }));
            }), operators_1.map(([b, s]) => [
                {
                    success: b.success && s.success,
                    error: b.error || s.error,
                },
                nodeServerPort,
            ]), operators_1.tap(([builderOutput]) => {
                if (builderOutput.success) {
                    context.logger.info('\nCompiled successfully.');
                }
            }), operators_1.debounce(([builderOutput]) => builderOutput.success && !options.inspect
                ? utils_1.waitUntilServerIsListening(nodeServerPort)
                : rxjs_1.EMPTY));
        }), operators_1.concatMap(([builderOutput, nodeServerPort]) => {
            if (!builderOutput.success) {
                return rxjs_1.of(builderOutput);
            }
            if (bsInstance.active) {
                bsInstance.reload();
                return rxjs_1.of(builderOutput);
            }
            else {
                return rxjs_1.from(initBrowserSync(bsInstance, nodeServerPort, options))
                    .pipe(operators_1.tap(bs => {
                    const baseUrl = getBaseUrl(bs);
                    context.logger.info(core_1.tags.oneLine `
                **
                Angular Universal Live Development Server is listening on ${baseUrl},
                open your browser on ${baseUrl}
                **
              `);
                }), operators_1.mapTo(builderOutput));
            }
        }), operators_1.map(builderOutput => ({
            success: builderOutput.success,
            error: builderOutput.error,
            baseUrl: bsInstance && getBaseUrl(bsInstance),
        })), operators_1.finalize(() => {
            if (bsInstance) {
                bsInstance.exit();
                bsInstance.cleanup();
            }
        }), operators_1.catchError(error => rxjs_1.of({
            success: false,
            error: mapErrorToMessage(error),
        })));
    }
    exports.execute = execute;
    function startNodeServer(serverOutput, port, logger, inspectMode = false) {
        const outputPath = serverOutput.outputPath;
        const path = path_1.join(outputPath, 'main.js');
        const env = Object.assign(Object.assign({}, process.env), { PORT: '' + port });
        const args = [`"${path}"`];
        if (inspectMode) {
            args.unshift('--inspect-brk');
        }
        return rxjs_1.of(null)
            .pipe(operators_1.delay(0), // Avoid EADDRINUSE error since it will cause the kill event to be finish.
        operators_1.switchMap(() => utils_1.spawnAsObservable('node', args, { env, shell: true })), operators_1.tap(({ stderr, stdout }) => {
            if (stderr) {
                logger.error(stderr);
            }
            if (stdout && !IGNORED_STDOUT_MESSAGES.some(x => stdout.includes(x))) {
                logger.info(stdout);
            }
        }), operators_1.ignoreElements(), 
        // Emit a signal after the process has been started
        operators_1.startWith(undefined));
    }
    function initBrowserSync(browserSyncInstance, nodeServerPort, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (browserSyncInstance.active) {
                return browserSyncInstance;
            }
            const { port: browserSyncPort, open, host, publicHost } = options;
            const bsPort = browserSyncPort || (yield utils_1.getAvailablePort());
            const bsOptions = {
                proxy: {
                    target: `localhost:${nodeServerPort}`,
                    proxyOptions: {
                        xfwd: true
                    },
                    proxyRes: [
                        proxyRes => {
                            if ('headers' in proxyRes) {
                                proxyRes.headers['cache-control'] = undefined;
                            }
                        },
                    ]
                    // proxyOptions is not in the typings
                },
                host,
                port: bsPort,
                ui: false,
                server: false,
                notify: false,
                ghostMode: false,
                logLevel: 'silent',
                open,
            };
            const publicHostNormalized = publicHost && publicHost.endsWith('/')
                ? publicHost.substring(0, publicHost.length - 1)
                : publicHost;
            if (publicHostNormalized) {
                const { protocol, hostname, port, pathname } = url.parse(publicHostNormalized);
                const defaultSocketIoPath = '/browser-sync/socket.io';
                const defaultNamespace = '/browser-sync';
                const hasPathname = !!(pathname && pathname !== '/');
                const namespace = hasPathname ? pathname + defaultNamespace : defaultNamespace;
                const path = hasPathname ? pathname + defaultSocketIoPath : defaultSocketIoPath;
                bsOptions.socket = {
                    namespace,
                    path,
                    domain: url.format({
                        protocol,
                        hostname,
                        port,
                    }),
                };
                // When having a pathname we also need to create a reverse proxy because socket.io
                // will be listening on: 'http://localhost:4200/ssr/browser-sync/socket.io'
                // However users will typically have a reverse proxy that will redirect all matching requests
                // ex: http://testinghost.com/ssr -> http://localhost:4200 which will result in a 404.
                if (hasPathname) {
                    // Remove leading slash
                    bsOptions.scriptPath = p => p.substring(1),
                        bsOptions.middleware = [
                            http_proxy_middleware_1.createProxyMiddleware(defaultSocketIoPath, {
                                target: url.format({
                                    protocol: 'http',
                                    hostname: host,
                                    port: bsPort,
                                    pathname: path,
                                }),
                                ws: true,
                                logLevel: 'silent',
                            }),
                        ];
                }
            }
            return new Promise((resolve, reject) => {
                browserSyncInstance.init(bsOptions, (error, bs) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(bs);
                    }
                });
            });
        });
    }
    function mapErrorToMessage(error) {
        if (error instanceof Error) {
            return error.message;
        }
        if (typeof error === 'string') {
            return error;
        }
        return '';
    }
    exports.default = architect_1.createBuilder(execute);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9zc3ItZGV2LXNlcnZlci9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFSCx5REFLbUM7SUFDbkMsK0NBQTJEO0lBQzNELDRDQUE0QztJQUM1QyxpRUFBOEQ7SUFDOUQsK0JBQTRCO0lBQzVCLCtCQU9jO0lBQ2QsOENBYXdCO0lBQ3hCLDJCQUEyQjtJQUczQiwwRUFBMEY7SUFFMUYsd0RBQXdEO0lBQ3hELE1BQU0sdUJBQXVCLEdBQUc7UUFDOUIscUJBQXFCO1FBQ3JCLDBGQUEwRjtLQUMzRixDQUFDO0lBUUYsU0FBZ0IsT0FBTyxDQUNyQixPQUFtQyxFQUNuQyxPQUF1QjtRQUV2QixNQUFNLGFBQWEsR0FBRyxrQ0FBc0IsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDcEUsTUFBTSxZQUFZLEdBQUcsa0NBQXNCLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sVUFBVSxHQUFHLENBQUMsRUFBbUMsRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBRTFJLE1BQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUU7WUFDN0QsYUFBYSxFQUFFLEtBQUs7WUFDcEIsS0FBSyxFQUFFLElBQUk7WUFDWCxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVE7U0FDM0IsQ0FBQyxDQUFDO1FBRUgsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUU7WUFDM0QsS0FBSyxFQUFFLElB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QUFFLEVBQUUsRUFBRSxFQUFFO29CQUNoRCxJQUFJLEtBQUssRUFBRTt3QkFDVCxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7cUJBQ2Y7eUJBQU07d0JBQ0wsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO3FCQUNiO2dCQUNILENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDO0tBQUE7SUFFRCxTQUFTLGlCQUFpQixDQUFDLEtBQWM7UUFDdkMsSUFBSSxLQUFLLFlBQVksS0FBSyxFQUFFO1lBQzFCLE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQztTQUN0QjtRQUVELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1lBQzdCLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFFRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxrQkFBZSx5QkFBYSxDQUE0QyxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICBCdWlsZGVyQ29udGV4dCxcbiAgQnVpbGRlck91dHB1dCxcbiAgY3JlYXRlQnVpbGRlcixcbiAgdGFyZ2V0RnJvbVRhcmdldFN0cmluZyxcbn0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2FyY2hpdGVjdCc7XG5pbXBvcnQgeyBqc29uLCBsb2dnaW5nLCB0YWdzIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2NvcmUnO1xuaW1wb3J0ICogYXMgYnJvd3NlclN5bmMgZnJvbSAnYnJvd3Nlci1zeW5jJztcbmltcG9ydCB7IGNyZWF0ZVByb3h5TWlkZGxld2FyZSB9IGZyb20gJ2h0dHAtcHJveHktbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQge1xuICBFTVBUWSxcbiAgT2JzZXJ2YWJsZSxcbiAgY29tYmluZUxhdGVzdCxcbiAgZnJvbSxcbiAgb2YsXG4gIHppcCxcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBjb25jYXRNYXAsXG4gIGRlYm91bmNlLFxuICBkZWJvdW5jZVRpbWUsXG4gIGRlbGF5LFxuICBmaW5hbGl6ZSxcbiAgaWdub3JlRWxlbWVudHMsXG4gIG1hcCxcbiAgbWFwVG8sXG4gIHN0YXJ0V2l0aCxcbiAgc3dpdGNoTWFwLFxuICB0YXAsXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCAqIGFzIHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnLi9zY2hlbWEnO1xuXG5pbXBvcnQgeyBnZXRBdmFpbGFibGVQb3J0LCBzcGF3bkFzT2JzZXJ2YWJsZSwgd2FpdFVudGlsU2VydmVySXNMaXN0ZW5pbmcgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqIExvZyBtZXNzYWdlcyB0byBpZ25vcmUgYW5kIG5vdCByZWx5IHRvIHRoZSBsb2dnZXIgKi9cbmNvbnN0IElHTk9SRURfU1RET1VUX01FU1NBR0VTID0gW1xuICAnc2VydmVyIGxpc3RlbmluZyBvbicsXG4gICdBbmd1bGFyIGlzIHJ1bm5pbmcgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gQ2FsbCBlbmFibGVQcm9kTW9kZSgpIHRvIGVuYWJsZSBwcm9kdWN0aW9uIG1vZGUuJ1xuXTtcblxuXG5leHBvcnQgdHlwZSBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3B0aW9ucyA9IFNjaGVtYSAmIGpzb24uSnNvbk9iamVjdDtcbmV4cG9ydCB0eXBlIFNTUkRldlNlcnZlckJ1aWxkZXJPdXRwdXQgPSBCdWlsZGVyT3V0cHV0ICYge1xuICBiYXNlVXJsPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGUoXG4gIG9wdGlvbnM6IFNTUkRldlNlcnZlckJ1aWxkZXJPcHRpb25zLFxuICBjb250ZXh0OiBCdWlsZGVyQ29udGV4dCxcbik6IE9ic2VydmFibGU8U1NSRGV2U2VydmVyQnVpbGRlck91dHB1dD4ge1xuICBjb25zdCBicm93c2VyVGFyZ2V0ID0gdGFyZ2V0RnJvbVRhcmdldFN0cmluZyhvcHRpb25zLmJyb3dzZXJUYXJnZXQpO1xuICBjb25zdCBzZXJ2ZXJUYXJnZXQgPSB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nKG9wdGlvbnMuc2VydmVyVGFyZ2V0KTtcbiAgY29uc3QgZ2V0QmFzZVVybCA9IChiczogYnJvd3NlclN5bmMuQnJvd3NlclN5bmNJbnN0YW5jZSkgPT4gYCR7YnMuZ2V0T3B0aW9uKCdzY2hlbWUnKX06Ly8ke2JzLmdldE9wdGlvbignaG9zdCcpfToke2JzLmdldE9wdGlvbigncG9ydCcpfWA7XG5cbiAgY29uc3QgYnJvd3NlclRhcmdldFJ1biA9IGNvbnRleHQuc2NoZWR1bGVUYXJnZXQoYnJvd3NlclRhcmdldCwge1xuICAgIHNlcnZpY2VXb3JrZXI6IGZhbHNlLFxuICAgIHdhdGNoOiB0cnVlLFxuICAgIHByb2dyZXNzOiBvcHRpb25zLnByb2dyZXNzLFxuICB9KTtcblxuICBjb25zdCBzZXJ2ZXJUYXJnZXRSdW4gPSBjb250ZXh0LnNjaGVkdWxlVGFyZ2V0KHNlcnZlclRhcmdldCwge1xuICAgIHdhdGNoOiB0cnVlLFxuICAgIHByb2dyZXNzOiBvcHRpb25zLnByb2dyZXNzLFxuICB9KTtcblxuICBjb25zdCBic0luc3RhbmNlID0gYnJvd3NlclN5bmMuY3JlYXRlKCk7XG5cbiAgY29udGV4dC5sb2dnZXIuZXJyb3IodGFncy5zdHJpcEluZGVudHNgXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgVGhpcyBpcyBhIHNpbXBsZSBzZXJ2ZXIgZm9yIHVzZSBpbiB0ZXN0aW5nIG9yIGRlYnVnZ2luZyBBbmd1bGFyIGFwcGxpY2F0aW9ucyBsb2NhbGx5LlxuICBJdCBoYXNuJ3QgYmVlbiByZXZpZXdlZCBmb3Igc2VjdXJpdHkgaXNzdWVzLlxuXG4gIERPTidUIFVTRSBJVCBGT1IgUFJPRFVDVElPTiFcbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIGApO1xuXG4gIHJldHVybiB6aXAoXG4gICAgYnJvd3NlclRhcmdldFJ1bixcbiAgICBzZXJ2ZXJUYXJnZXRSdW4sXG4gICAgZ2V0QXZhaWxhYmxlUG9ydCgpLFxuICApLnBpcGUoXG4gICAgc3dpdGNoTWFwKChbYnIsIHNyLCBub2RlU2VydmVyUG9ydF0pID0+IHtcbiAgICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFtici5vdXRwdXQsIHNyLm91dHB1dF0pLnBpcGUoXG4gICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIHNvIHRoYXQgaWYgYm90aCBzZXJ2ZXIgYW5kIGJyb3dzZXIgZW1pdCBjbG9zZSB0byBlYWNoIG90aGVyXG4gICAgICAgIC8vIHdlIG9ubHkgZW1pdCBvbmNlLiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIG9uIHRoZSBmaXJzdCBidWlsZC5cbiAgICAgICAgZGVib3VuY2VUaW1lKDEyMCksXG4gICAgICAgIHN3aXRjaE1hcCgoW2IsIHNdKSA9PiB7XG4gICAgICAgICAgaWYgKCFzLnN1Y2Nlc3MgfHwgIWIuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIG9mKFtiLCBzXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0YXJ0Tm9kZVNlcnZlcihzLCBub2RlU2VydmVyUG9ydCwgY29udGV4dC5sb2dnZXIsICEhb3B0aW9ucy5pbnNwZWN0KS5waXBlKFxuICAgICAgICAgICAgbWFwVG8oW2IsIHNdKSxcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHtcbiAgICAgICAgICAgICAgY29udGV4dC5sb2dnZXIuZXJyb3IoYEEgc2VydmVyIGVycm9yIGhhcyBvY2N1cnJlZC5cXG4ke21hcEVycm9yVG9NZXNzYWdlKGVycil9YCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcCgoW2IsIHNdKSA9PiAoW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGIuc3VjY2VzcyAmJiBzLnN1Y2Nlc3MsXG4gICAgICAgICAgICBlcnJvcjogYi5lcnJvciB8fCBzLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbm9kZVNlcnZlclBvcnQsXG4gICAgICAgIF0gYXMgW1NTUkRldlNlcnZlckJ1aWxkZXJPdXRwdXQsIG51bWJlcl0pKSxcbiAgICAgICAgdGFwKChbYnVpbGRlck91dHB1dF0pID0+IHtcbiAgICAgICAgICBpZiAoYnVpbGRlck91dHB1dC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKCdcXG5Db21waWxlZCBzdWNjZXNzZnVsbHkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVib3VuY2UoKFtidWlsZGVyT3V0cHV0XSkgPT4gYnVpbGRlck91dHB1dC5zdWNjZXNzICYmICFvcHRpb25zLmluc3BlY3RcbiAgICAgICAgICA/IHdhaXRVbnRpbFNlcnZlcklzTGlzdGVuaW5nKG5vZGVTZXJ2ZXJQb3J0KVxuICAgICAgICAgIDogRU1QVFkpXG4gICAgICApO1xuICAgIH0pLFxuICAgIGNvbmNhdE1hcCgoW2J1aWxkZXJPdXRwdXQsIG5vZGVTZXJ2ZXJQb3J0XSkgPT4ge1xuICAgICAgaWYgKCFidWlsZGVyT3V0cHV0LnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIG9mKGJ1aWxkZXJPdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnNJbnN0YW5jZS5hY3RpdmUpIHtcbiAgICAgICAgYnNJbnN0YW5jZS5yZWxvYWQoKTtcblxuICAgICAgICByZXR1cm4gb2YoYnVpbGRlck91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnJvbShpbml0QnJvd3NlclN5bmMoYnNJbnN0YW5jZSwgbm9kZVNlcnZlclBvcnQsIG9wdGlvbnMpKVxuICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgdGFwKGJzID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwoYnMpO1xuICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKHRhZ3Mub25lTGluZWBcbiAgICAgICAgICAgICAgICAqKlxuICAgICAgICAgICAgICAgIEFuZ3VsYXIgVW5pdmVyc2FsIExpdmUgRGV2ZWxvcG1lbnQgU2VydmVyIGlzIGxpc3RlbmluZyBvbiAke2Jhc2VVcmx9LFxuICAgICAgICAgICAgICAgIG9wZW4geW91ciBicm93c2VyIG9uICR7YmFzZVVybH1cbiAgICAgICAgICAgICAgICAqKlxuICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFwVG8oYnVpbGRlck91dHB1dCksXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBtYXAoYnVpbGRlck91dHB1dCA9PiAoe1xuICAgICAgc3VjY2VzczogYnVpbGRlck91dHB1dC5zdWNjZXNzLFxuICAgICAgZXJyb3I6IGJ1aWxkZXJPdXRwdXQuZXJyb3IsXG4gICAgICBiYXNlVXJsOiBic0luc3RhbmNlICYmIGdldEJhc2VVcmwoYnNJbnN0YW5jZSksXG4gICAgfSBhcyBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3V0cHV0KSksXG4gICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgaWYgKGJzSW5zdGFuY2UpIHtcbiAgICAgICAgYnNJbnN0YW5jZS5leGl0KCk7XG4gICAgICAgIGJzSW5zdGFuY2UuY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGNhdGNoRXJyb3IoZXJyb3IgPT4gb2Yoe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbWFwRXJyb3JUb01lc3NhZ2UoZXJyb3IpLFxuICAgIH0pKSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gc3RhcnROb2RlU2VydmVyKFxuICBzZXJ2ZXJPdXRwdXQ6IEJ1aWxkZXJPdXRwdXQsXG4gIHBvcnQ6IG51bWJlcixcbiAgbG9nZ2VyOiBsb2dnaW5nLkxvZ2dlckFwaSxcbiAgaW5zcGVjdE1vZGUgPSBmYWxzZSxcbik6IE9ic2VydmFibGU8dm9pZD4ge1xuICBjb25zdCBvdXRwdXRQYXRoID0gc2VydmVyT3V0cHV0Lm91dHB1dFBhdGggYXMgc3RyaW5nO1xuICBjb25zdCBwYXRoID0gam9pbihvdXRwdXRQYXRoLCAnbWFpbi5qcycpO1xuICBjb25zdCBlbnYgPSB7IC4uLnByb2Nlc3MuZW52LCBQT1JUOiAnJyArIHBvcnQgfTtcblxuICBjb25zdCBhcmdzID0gW2BcIiR7cGF0aH1cImBdO1xuICBpZiAoaW5zcGVjdE1vZGUpIHtcbiAgICBhcmdzLnVuc2hpZnQoJy0taW5zcGVjdC1icmsnKTtcbiAgfVxuXG4gIHJldHVybiBvZihudWxsKVxuICAgIC5waXBlKFxuICAgICAgZGVsYXkoMCksIC8vIEF2b2lkIEVBRERSSU5VU0UgZXJyb3Igc2luY2UgaXQgd2lsbCBjYXVzZSB0aGUga2lsbCBldmVudCB0byBiZSBmaW5pc2guXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gc3Bhd25Bc09ic2VydmFibGUoJ25vZGUnLCBhcmdzLCB7IGVudiwgc2hlbGw6IHRydWUgfSkpLFxuICAgICAgdGFwKCh7IHN0ZGVyciwgc3Rkb3V0IH0pID0+IHtcbiAgICAgICAgaWYgKHN0ZGVycikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihzdGRlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZG91dCAmJiAhSUdOT1JFRF9TVERPVVRfTUVTU0FHRVMuc29tZSh4ID0+IHN0ZG91dC5pbmNsdWRlcyh4KSkpIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhzdGRvdXQpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGlnbm9yZUVsZW1lbnRzKCksXG4gICAgICAvLyBFbWl0IGEgc2lnbmFsIGFmdGVyIHRoZSBwcm9jZXNzIGhhcyBiZWVuIHN0YXJ0ZWRcbiAgICAgIHN0YXJ0V2l0aCh1bmRlZmluZWQpLFxuICAgICk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXRCcm93c2VyU3luYyhcbiAgYnJvd3NlclN5bmNJbnN0YW5jZTogYnJvd3NlclN5bmMuQnJvd3NlclN5bmNJbnN0YW5jZSxcbiAgbm9kZVNlcnZlclBvcnQ6IG51bWJlcixcbiAgb3B0aW9uczogU1NSRGV2U2VydmVyQnVpbGRlck9wdGlvbnMsXG4pOiBQcm9taXNlPGJyb3dzZXJTeW5jLkJyb3dzZXJTeW5jSW5zdGFuY2U+IHtcbiAgaWYgKGJyb3dzZXJTeW5jSW5zdGFuY2UuYWN0aXZlKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJTeW5jSW5zdGFuY2U7XG4gIH1cblxuICBjb25zdCB7IHBvcnQ6IGJyb3dzZXJTeW5jUG9ydCwgb3BlbiwgaG9zdCwgcHVibGljSG9zdCB9ID0gb3B0aW9ucztcbiAgY29uc3QgYnNQb3J0ID0gYnJvd3NlclN5bmNQb3J0IHx8IGF3YWl0IGdldEF2YWlsYWJsZVBvcnQoKTtcbiAgY29uc3QgYnNPcHRpb25zOiBicm93c2VyU3luYy5PcHRpb25zID0ge1xuICAgIHByb3h5OiB7XG4gICAgICB0YXJnZXQ6IGBsb2NhbGhvc3Q6JHtub2RlU2VydmVyUG9ydH1gLFxuICAgICAgcHJveHlPcHRpb25zOiB7XG4gICAgICAgIHhmd2Q6IHRydWVcbiAgICAgIH0sXG4gICAgICBwcm94eVJlczogW1xuICAgICAgICBwcm94eVJlcyA9PiB7XG4gICAgICAgICAgaWYgKCdoZWFkZXJzJyBpbiBwcm94eVJlcykge1xuICAgICAgICAgICAgcHJveHlSZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIF1cbiAgICAgIC8vIHByb3h5T3B0aW9ucyBpcyBub3QgaW4gdGhlIHR5cGluZ3NcbiAgICB9IGFzIGJyb3dzZXJTeW5jLlByb3h5T3B0aW9ucyAmIHsgcHJveHlPcHRpb25zOiB7IHhmd2Q6IGJvb2xlYW4gfSB9LFxuICAgIGhvc3QsXG4gICAgcG9ydDogYnNQb3J0LFxuICAgIHVpOiBmYWxzZSxcbiAgICBzZXJ2ZXI6IGZhbHNlLFxuICAgIG5vdGlmeTogZmFsc2UsXG4gICAgZ2hvc3RNb2RlOiBmYWxzZSxcbiAgICBsb2dMZXZlbDogJ3NpbGVudCcsXG4gICAgb3BlbixcbiAgfTtcblxuICBjb25zdCBwdWJsaWNIb3N0Tm9ybWFsaXplZCA9IHB1YmxpY0hvc3QgJiYgcHVibGljSG9zdC5lbmRzV2l0aCgnLycpXG4gICAgPyBwdWJsaWNIb3N0LnN1YnN0cmluZygwLCBwdWJsaWNIb3N0Lmxlbmd0aCAtIDEpXG4gICAgOiBwdWJsaWNIb3N0O1xuXG4gIGlmIChwdWJsaWNIb3N0Tm9ybWFsaXplZCkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0LCBwYXRobmFtZSB9ID0gdXJsLnBhcnNlKHB1YmxpY0hvc3ROb3JtYWxpemVkKTtcbiAgICBjb25zdCBkZWZhdWx0U29ja2V0SW9QYXRoID0gJy9icm93c2VyLXN5bmMvc29ja2V0LmlvJztcbiAgICBjb25zdCBkZWZhdWx0TmFtZXNwYWNlID0gJy9icm93c2VyLXN5bmMnO1xuICAgIGNvbnN0IGhhc1BhdGhuYW1lID0gISEocGF0aG5hbWUgJiYgcGF0aG5hbWUgIT09ICcvJyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gaGFzUGF0aG5hbWUgPyBwYXRobmFtZSArIGRlZmF1bHROYW1lc3BhY2UgOiBkZWZhdWx0TmFtZXNwYWNlO1xuICAgIGNvbnN0IHBhdGggPSBoYXNQYXRobmFtZSA/IHBhdGhuYW1lICsgZGVmYXVsdFNvY2tldElvUGF0aCA6IGRlZmF1bHRTb2NrZXRJb1BhdGg7XG5cbiAgICBic09wdGlvbnMuc29ja2V0ID0ge1xuICAgICAgbmFtZXNwYWNlLFxuICAgICAgcGF0aCxcbiAgICAgIGRvbWFpbjogdXJsLmZvcm1hdCh7XG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcG9ydCxcbiAgICAgIH0pLFxuICAgIH07XG5cbiAgICAvLyBXaGVuIGhhdmluZyBhIHBhdGhuYW1lIHdlIGFsc28gbmVlZCB0byBjcmVhdGUgYSByZXZlcnNlIHByb3h5IGJlY2F1c2Ugc29ja2V0LmlvXG4gICAgLy8gd2lsbCBiZSBsaXN0ZW5pbmcgb246ICdodHRwOi8vbG9jYWxob3N0OjQyMDAvc3NyL2Jyb3dzZXItc3luYy9zb2NrZXQuaW8nXG4gICAgLy8gSG93ZXZlciB1c2VycyB3aWxsIHR5cGljYWxseSBoYXZlIGEgcmV2ZXJzZSBwcm94eSB0aGF0IHdpbGwgcmVkaXJlY3QgYWxsIG1hdGNoaW5nIHJlcXVlc3RzXG4gICAgLy8gZXg6IGh0dHA6Ly90ZXN0aW5naG9zdC5jb20vc3NyIC0+IGh0dHA6Ly9sb2NhbGhvc3Q6NDIwMCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIDQwNC5cbiAgICBpZiAoaGFzUGF0aG5hbWUpIHtcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHNsYXNoXG4gICAgICBic09wdGlvbnMuc2NyaXB0UGF0aCA9IHAgPT4gcC5zdWJzdHJpbmcoMSksXG4gICAgICAgIGJzT3B0aW9ucy5taWRkbGV3YXJlID0gW1xuICAgICAgICAgIGNyZWF0ZVByb3h5TWlkZGxld2FyZShkZWZhdWx0U29ja2V0SW9QYXRoLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHVybC5mb3JtYXQoe1xuICAgICAgICAgICAgICBwcm90b2NvbDogJ2h0dHAnLFxuICAgICAgICAgICAgICBob3N0bmFtZTogaG9zdCxcbiAgICAgICAgICAgICAgcG9ydDogYnNQb3J0LFxuICAgICAgICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd3M6IHRydWUsXG4gICAgICAgICAgICBsb2dMZXZlbDogJ3NpbGVudCcsXG4gICAgICAgICAgfSkgYXMgYW55LFxuICAgICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYnJvd3NlclN5bmNJbnN0YW5jZS5pbml0KGJzT3B0aW9ucywgKGVycm9yLCBicykgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGJzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1hcEVycm9yVG9NZXNzYWdlKGVycm9yOiB1bmtub3duKTogc3RyaW5nIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCdWlsZGVyPFNTUkRldlNlcnZlckJ1aWxkZXJPcHRpb25zLCBCdWlsZGVyT3V0cHV0PihleGVjdXRlKTtcbiJdfQ==